#d3p}|{y_b_kyrc3

Исходный обфусцированный код https://github.com/rprtr258/calculator/blob/master/deobsfucate/obfuscate.c (со статьи на википедии про обсфукацию)
Более человеческий код: https://github.com/rprtr258/calculator/blob/master/deobsfucate/main.c

Выводит текст песни про 12 дней Рождества(Christmas). Все происходит через рекурсию через абуз функции main. Аргументы функции не указаны кроме третьего, поэтому параметры main следующие:
t: int
_: int
a: char*

Назначения аргументов:
t - отвечает за состояние внутри функции при выводе какой-либо части строки, изначально равна 1, из-за чего меняется в куске вызываемом единственный раз
main ( 2, 2 , "%s")
и становится равен 2. Если t = 2, то main выводит часть строфы, если t принимает другое значение, то значит внутри функции обрабатывается строка для вывода и t индицирует это состояние.
_ - имеет два предназначения: если t = 2 и main выводит строфу, то _ это номер строфы + 1, иначе это символ, который обрабатывается для дальнейшего вывода, ввиду вышеуказанной строки изначально равен 2(1 строфа)
a - строка, которая нужна для вывода текущей части строфы, форматирующие строки литерали в программе не нужны и могут быть убраны("%s" и "%s %d %d\n")

Функция main содержит огромные вложенные тернарные операторы, которые разделяют различные состояния и заодно возвращают значение функции. Если ветка условия не нужна(а обе ветки необходимы в тернарном операторе) то указано какое-то число и запятая:
t < _ ?
    main(t+1, _, a )
:
    3, // ветка игнорируется
Для разделения последовательных операторов используется вышеуказанная запятая.

Далее речь идет уже про преобразованный код, в котором поток выполнения почти полностью совпадает с исходной программой.

Вывод строфы разделяется на несколько частей:
0) "On the " - неизменяемая часть
1) "fifth" - номер дня в виде строки(устанавливается при t = 2 и c = номер_дня + 1)
2) " day of Christmas my true love gave to me\n" - неизменяемая часть
3) "five gold rings;\nfour calling birds, three french hens, two turtle doves" - часть, которая рекурсивно дополняется в зависимости от c(берется текущая и все предыдущие, отсутствует в первой строфе)
4) "and a partridge in a pear tree.\n\n" - неизменяемая часть

Все возможные части строки зашифрованы в двух строковых литералах:
Ключ:
"!ek;dc i@bK'(q)-[w]*%n+r3#l,{}:\nuwloca-O;m .vpbks,fxntdCeghiry"
Шифр:
"@n'+,#'/*{}w+/w#cdnr/+,{}r/*de}+,/*{*+,/w{%+,/w#q#n+,/#{l,+,/n{n+,/+#n+,/#;#q#n+,/+k#;*+,/'r :'d*'3,}{w+K w'K:'+}e#';dq#'l q#'+d'K#!/+k#;q#'r}eKK#}w'r}eKK{nl]'/#;#q#n'){)#}w'){){nl]'/+#n';d}rw' i;# ){nl]!/n{n#'; r{#w'r nc{nl]'/#{l,+'K {rw' iK{;[{nl]'/w#q#n'wk nw' iwk{KK{nl]!/w{%'l##w#' i; :{nl]'/*{q#'ld;r'}{nlwb!/*de}'c ;;{nl'-{}rw]'/+,}##'*}#nc,',#nw]'/+kd'+e}+;#'rdq#w! nr'/ ') }+}{rl#'{n' ')# }'+}##(!!/"
Шифрование заключается в замене одних символов на другие, и ключ выглядит так:
АЛФАВИТ|ИСХОДНЫЕ_СИМВОЛЫ
Исходные символы располагаются на расстоянии 31 поэтому расшифровка осуществляется следующим образом: каждому символу шифра соответствует один символ который получается так:
1. берем очередной символ шифра
2. находим его в ключе
3. отступаем от него на 31 позицию вправо(putchar(31[a]) эквивалентно putchar(a[31])) и нужный символ тот который там будет
Для разделителей используется слеш '/' который декодируется в двоеточие ':'
Процесс расшифровки показан в следующей программе:
https://github.com/rprtr258/calculator/blob/master/deobsfucate/decoder.py

Так как вывод строф происходит при t = 2, этот случай можно выделить в отдельную функцию:
// prints (c - 1)-th verse
void printVerse(int c) {
    func(-79, 0, 0); // 0) "On the "
    func(-87, 1 - c, 0); // 1) day number
    func(-86, -13, 0); // 2) " day of Christmas my true love gave to me\n"
    if (2 < c) { // if not 1st verse
        func(2 + 1, c, 0); // 3) presents
    }
    func(-94, 2 - 27, 0); // 4) "a partridge in a pear tree.\n\n"
    if (c < 13) { // if not last verse
        printVerse(c + 1); // tail recursion to next verse
    }
}

Разберет вывод строфы подробнее, така как это единственное, что осталось не до конца разобранным. Сначала вызвается функция от аргументов t = -79, c = 0 что приводит нас по веткам условий к:
res = func(c, t, CYPHER); // func(0, -65, CYPHER)
здесть t и c переставляются местами и третьим аргументом передается шифр, дальше пойдет расшифровка первой части строфы. Так как t = 0, то вызов переходит к:
if (t == 0) {
    int tmp = func(-61, s[0], KEY);
    res = (s[0] == '/' || func(0, tmp, s + 1));
}
Здесть вызывается func при t = -61, c = s[0](первый символ в шифре), s = KEY(строка где будет осуществляться поиск).
Далее идет хвостовая рекурсия в условии:
if (t < -50) { 
    if (c == s[0]) {
        res = putchar(s[31]);
    } else {
        res = func(-65, c, s + 1);
    }
}
где происходит переход к следующему символу при несовпадении и где происходит в первой ветке вывод символа отстоящего на 31 при совпадении. В конце концов мы выводим первый символ и возвращаемся к случаю t = 0:
if (t == 0) {
    int tmp = func(-61, s[0], KEY);
    res = (s[0] == '/' || func(0, tmp, s + 1));
}
tmp как второй параметр func при вызове во второй строке НЕ ИСПОЛЬЗУЕТСЯ поэтому он там для красоты. Соответственно, если в шифре был прочитан символ слеша, то вывод заканчивается, иначе продолжается до разделителя. Таким образом выводится первая часть строф "On the ".
Затем рассмотрим как происходит вывод номера дня. Во второй строке функции вывода строфы:
func(-86, 1 - c, 0); // day number
t = -86, c = 1 - c что ведет к ситуации опять:
res = func(c, t, CYPHER); // func(1 - с, -86, CYPHER)
Далее уже переход идем к доселе невиданной строке:
res = func((s[0] == '/') + t, c, s + 1); // func(1 - c, -86, CYPHER + 1)
Это опять хвостовая рекурсия, которая пропускает c - 1 разделителей и тем самым обнуляет первый аргумент t. После чего происходит уже описанный вывод строки в виде найденного номера дня.
Ровно такими же пропусками разделителей выводится 2) часть строф. Затем рассмотрим рекурсию изменяемой части:
func(2 + 1, c, 0); // presents
так как t = 3 выполняется опять таки доселе невиданная ветка:
if (t < c) {
    func(t + 1, c, s);
}
if (func(-94, t - 27, s) && t == 2 && c < 13) {
    func(2, c + 1, "%s %d %d\n");
}
В первом условии происходит проверка на то, что выводимый подарок под номером соответствующим t не превосходит дня c и вызывается опять таки хвостовая рекурсия. Она в конце концов заходит во вторую ветку и пропуская 27 - t разделителей выводит подарок. Затем возвращается и выводит следующий подарок. И так далее до текущего дня.
Затем печатается следующая строфа и все начинается со следующего дня.
printVerse(c + 1);